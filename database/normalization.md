# Проектирование базы данных для Read-Tracker

В этом документе описан процесс проектирования и нормализации базы данных
для приложения отслеживания чтения книг **Read-Tracker**.

## Предметная область

Приложение позволяет пользователю вести список книг,
отмечать статус чтения, привязывать жанры и фиксировать сессии чтения
(когда и сколько страниц было прочитано).

Основные объекты предметной области:

- Пользователь (User)
- Книга (Book)
- Статус чтения (Status)
- Жанр (Genre)
- Сессия чтения (Reading Session)

## Денормализованная исходная таблица

На первом шаге представим, что все данные хранятся в одной таблице:

`ReadingLog(log_id, user_id, username, user_email,
book_id, book_title, book_author, total_pages,
status_name,
genre_id, genre_name,
session_id, session_date, pages_read, duration_minutes, note)`

### Проблемы такой структуры

- **Избыточность**:
  - username и user_email повторяются в каждой записи чтения пользователя;
  - данные книги и жанров дублируются для каждой сессии.
- **Аномалии обновления**:
  - изменение email пользователя требует обновить все строки с этим пользователем.
- **Аномалии удаления**:
  - удалив последнюю сессию чтения книги, можно потерять информацию о самой книге.
- **Аномалии вставки**:
  - невозможно создать пользователя без хотя бы одной записи чтения.

## Нормализация до 1NF

**Цель**: убрать повторяющиеся группы и обеспечить атомарность атрибутов.

**Решение**:

- Выделяем отдельные сущности в таблицы:
  - `Users` — данные пользователей;
  - `Books` — данные книг;
  - `Statuses` — справочник статусов чтения;
  - `Genres` — справочник жанров;
  - `Reading_Sessions` — отдельные сессии чтения;
  - `Book_Genres` — связь многие-ко-многим между книгами и жанрами.

Все атрибуты становятся атомарными, нет списков значений в одном поле.

## Нормализация до 2NF

**Цель**: устранить частичные зависимости неключевых атрибутов
от части составного ключа.

- В связующей таблице `Book_Genres(book_id, genre_id, genre_name)`
  атрибут `genre_name` зависит только от `genre_id`, а не от всего составного ключа.
- Выносим `genre_name` (и описание) в отдельную таблицу `Genres(genre_id, name, description)`.
- В остальных таблицах первичные ключи простые (`user_id`, `book_id`, `session_id`),
  поэтому частичных зависимостей нет.

**Результат**: для таблиц с составным ключом все неключевые атрибуты
зависят от полного ключа.

## Нормализация до 3NF

**Цель**: устранить транзитивные зависимости
(когда неключевой атрибут зависит от другого неключевого атрибута).

- Статус чтения (`status_name`) вынесен в справочник `Statuses`,
  в таблице `Books` хранится только `status_id`.
- Жанр (`genre_name`, `description`) вынесен в `Genres`,
  связь с книгами реализована через `Book_Genres`.
- Данные о пользователе (`username`, `email`) хранятся в таблице `Users`
  и не зависят от книг или сессий.

**Результат**: каждая таблица содержит только атрибуты,
которые зависят от её первичного ключа.

## Итоговая схема до 3NF

- **Users** (`user_id` PK, `username`, `email`, `created_at`)
- **Statuses** (`status_id` PK, `name`)
- **Genres** (`genre_id` PK, `name`, `description`)
- **Books** (`book_id` PK, `user_id` FK, `status_id` FK,
  `title`, `author`, `total_pages`,
  `started_at`, `finished_at`, `created_at`)
- **Book_Genres** (`book_id` FK, `genre_id` FK, PK (`book_id`, `genre_id`))
- **Reading_Sessions** (`session_id` PK, `user_id` FK, `book_id` FK,
  `session_date`, `pages_read`, `duration_minutes`, `note`)

## DDL-скрипты и тестовые данные

- Файл `database/schema.sql` содержит полный DDL-скрипт
  для создания схемы БД в SQLite, включая внешние ключи и индексы.
- Файл `database/seed_data.sql` содержит тестовые данные
  для проверки корректности структуры и выполнения запросов.

## Вывод

База данных Read-Tracker приведена к 3NF:

- уменьшена избыточность данных,
- устранены основные аномалии вставки, обновления и удаления,
- структура БД хорошо отражает предметную область приложения.
